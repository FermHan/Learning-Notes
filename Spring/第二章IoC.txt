

# 第2章  IOC容器和Bean的配置

## 2.1 IOC和DI

### 2.1.1 IOC(Inversion of Control)：反转控制

在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。

反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。

>  传统方式是主键主动地获取容器中的资源。

### 2.1.2 DI(Dependency Injection)：依赖注入

IOC的另一种表述方式：即组件以一些预先定义好的方式(例如：setter 方法)接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。

IOC 描述的是一种思想，而DI 是对IOC思想的具体实现. 

> 我们准备好接收容器创建的对象，以什么方式来接收呢，是通过DI来表示的。

### 2.1.3 IOC容器在Spring中的实现

1）在通过IOC容器读取Bean的实例之前，需要先将IOC容器本身实例化。

2）Spring提供了IOC容器的两种实现方式

① BeanFactory：IOC容器的基本实现，是Spring内部的基础设施，是面向Spring本身的，不是提供给开发人员使用的。

② ApplicationContext：BeanFactory的子接口，提供了更多高级特性。面向Spring的使用者，几乎所有场合都使用ApplicationContext而不是底层的BeanFactory。                                                  

>  Ctrl+Shift+T，可以输入类后查看类。搜索beanfactory，点Attach Source。选择第二项External，编码UTF-8，点External File，浏览到spring-framework-版本号-RELEASE-libs下的`spring-framework-版本号-RELEASE-source.jar`。加进来了源码。可以看到`BeanFactory`是一个接口，并且这个接口并没有继承。在接口上按Ctrl+T，可以看到类树。

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008201548.png)

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008204111.png)

### 2.1.4 ApplicationContext的主要实现类

1)        ClassPathXmlApplicationContext：对应类路径下的XML格式的配置文件

2)        FileSystemXmlApplicationContext：对应文件系统中的XML格式的配置文件

3)        在初始化时就创建单例的bean，也可以通过配置的方式指定创建的Bean是多实例的。

 

### 2.1.5 ConfigurableApplicationContext

1)        是ApplicationContext的子接口，包含一些扩展方法

2)        refresh()和close()让ApplicationContext具有启动、关闭和刷新上下文的能力。

 

### 2.1.6 WebApplicationContext

1)        专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作

 

## 2.2 通过类型获取bean

在BeanFactory类中有`getBean`的多个重载方法

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008204111.png)

1)        从IOC容器中获取bean时，除了通过id值获取，还可以通过bean的类型获取。但如果同一个类型的bean在XML文件中配置了多个，则获取时会抛出异常，所以同一个类型的bean在容器中必须是唯一的。

```JAVA
HelloWorld helloWorld = cxt.getBean(HelloWorld.class);//重载1，根据Class
HelloWorld helloWorld = cxt.getBean(“helloWorld”);//重载2，根据id
```

2)         或者可以使用另外一个重载的方法，同时指定bean的id值和类型

```JAVA
HelloWorld helloWorld = cxt.getBean(“helloWorld”,HelloWorld.class);//重载3，根据id+Class
```

## 2.3 给bean的属性赋值

### 2.3.1 依赖注入的方式

分为通过setXxx()方法【property】和构造器【constructor-arg】注入。

#### 1. 通过bean的setXxx()方法赋值

Hello World中使用的就是这种方式

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008205611.png)

#### 2. 通过bean的构造器赋值

相当于还是调用xml中的bean，但是把构造器的参数写到了xml中，所以调用的时候回在xml找到默认的值。

1)        Spring自动匹配合适的构造器

不能写name

 ```XML
<bean id="book" class="com.atguigu.spring.bean.Book" >
	<constructor-arg value= "10010"/>
	<constructor-arg value= "Book01"/>
	<constructor-arg value= "Author01"/>
	<constructor-arg value= "20.2"/>
</bean >
 ```


 通过索引值指定参数位置

```XML
<bean id="book" class="com.atguigu.spring.bean.Book" >
	<constructor-arg value= "10010" index ="0"/>
	<constructor-arg value= "Book01" index ="1"/>
	<constructor-arg value= "Author01" index ="2"/>
	<constructor-arg value= "20.2" index ="3"/>
</bean >
```

spring中IoC创建的时候回根据bean创建，会自动执行其中的set方法。

2)        通过类型区分重载的构造器

严格要求对应参数给到对应类型上，否则会出现"123"可以赋值给String这种情况。

```XML
<bean id="book" class="com.atguigu.spring.bean.Book" >
      <constructor-arg value= "10010" index ="0" type="java.lang.Integer" />
      <constructor-arg value= "Book01" index ="1" type="java.lang.String" />
      <constructor-arg value= "Author01" index ="2" type="java.lang.String" />
      <constructor-arg value= "20.2" index ="3" type="java.lang.Double" />
</bean >
```

>  构造器后面的最先匹配

### 2.3.2  p名称空间

​         为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。Spring从2.5版本开始引入了一个新的p命名空间，可以通过<bean>元素属性的方式配置Bean 的属性。

​         使用p命名空间后，基于XML的配置方式将进一步简化。

需要在namespaces选项里勾选p选项，底层使用的是set方式，所以需要定义对应的set方法。

没什么区别，更简洁了些而已

```XML
<bean 
	id="studentSuper" 
	class="com.atguigu.helloworld.bean.Student"
	p:studentId="2002" p:stuName="Jerry2016" p:age="18" 
/>
```

### 2.3.3 可以使用的值

#### 1. 字面量      

1)        可以使用字符串表示的值，可以通过value属性或value子节点的方式指定

2)        基本数据类型及其封装类、String等类型都可以采取字面值注入的方式

3)        若字面值中包含特殊字符，可以使用<![CDATA[]]>把字面值包裹起来

特殊字符可以采用实体或者使用<![CDATA[]]>，最好放在value标签中

#### 2. null值

```XML
<bean class="com.atguigu.spring.bean.Book" id="bookNull" >
	<property name= "bookId" value ="2000"/>
	<property name= "bookName">
	<null/>
	</property>
	<property name= "author" value ="nullAuthor"/>
	<property name= "price" value ="50"/>
</bean >
```

#### 3. 给bean的级联属性赋值

>  引用其他的bean（只能引用IoC里面的bean，不能去引用外面的），ref指定是引用的id，即原来的id改成用ref写了

```XML
<bean id="action" class="com.atguigu.spring.ref.Action">
	<property name="service" ref="service"/>
	<!-- 设置级联属性(了解) -->
	<property name="service.dao.dataSource" value="DBCP"/>
</bean>

---------------Person里有个Car类成员，-------------
<!-- 引用其他的bean -->
<bean id="person" class="com.atguigu.spring.di.Person">
    <property name="id" value="101"></property>
    <property name="name" value="宋老师"></property>
    <property name="car"  ref="car"></property>

    <!-- 给级联属性赋值-->
    <property name="car.speed" value="280"></property>
</bean>
--------因为前面已经定义过---------------
<bean id="car" class="com.atguigu.spring.di.Car">
    <property name="brand" value="奥迪">
    </property>
    <property name="crop" value="一汽"></property>
    <property name="price" value="400000"></property>
</bean>
```

#### 4. 外部已声明的bean

```xml
<bean id="person1" class="com.atguidu.spring.di.Person">
    <property name="score" value="88"></property>
    <bean id="shop" class="com.atguigu.spring.bean.Shop" >
		<property name= "book" ref ="book"/>
	</bean >
</bean>
```

#### 5. 内部bean

当bean实例仅仅给一个特定的属性使用时，可以将其声明为内部bean。内部bean声明直接包含在<property>或<constructor-arg>元素里，不需要设置任何id或name属性

内部bean不能使用在任何其他地方

```xml
<!-- 内部bean -->
<bean id="person1" class="com.atguigu.spring.di.Person">
    <property name="id" value="102"></property>
    <property name="name" value="婷姐"></property>
    <property name="car">
        <!-- 内部bean 只能 在内部使用.  -->
        <bean class="com.atguigu.spring.di.Car">
            <property name="brand" value="Mini"></property>
            <property name="crop" value="宝马"></property>
            <property name="price" value="300000"></property>
            <property name="speed" value="260"></property>
        </bean>
    </property>
</bean>
```

## 2.4 集合属性

在Spring中可以通过一组内置的XML标签来配置集合属性，例如：<list>，<set>或<map>。

### 2.4.1 数组和List

​         配置java.util.List类型的属性，需要指定<list>标签，在标签里包含一些元素。这些标签   可以通过<value>指定简单的常量值，【通过<ref>指定对其他Bean的引用】。通过<bean>      指定内置bean定义。通过<null/>指定空元素。甚至可以内嵌其他集合。

​         数组的定义和List一样，都使用<list>元素。

​         配置java.util.Set需要使用<set>标签，定义的方法与List一样。

```xml
public class PersonList {
	private String  name; 
	private List<Car> cars ; //注意这里
        ...
}
-----------------------------------------
<!-- List集合 -->
<bean id="personList" class="com.atguigu.spring.di.PersonList">
    <property name="name" value="Tom"></property>

    <!-- 构造集合，ref标签也可以改成内部bean
    <property name="cars">
        <list>
            <ref bean="car"/>
            <ref bean="car1"/>
            <ref bean="car2"/>
        </list>
    </property>
	-->
    <property name="cars" ref="listBean">
    </property>
</bean>
--------------------------------------------
<!-- 集合Bean -->
<util:list id="listBean">
    <ref bean="car"/>
    <ref bean="car1"/>
    <ref bean="car2"/>
    <!-- <bean>
   </bean> -->
</util:list>
```

### 2.4.2 Map

​         Java.util.Map通过<map>标签定义，<map>标签里可以使用多个<entry>作为子标签。每个条目包含一个键和一个值。

​         必须在<key>标签里定义键。

​         因为键和值的类型没有限制，所以可以自由地为它们指定<value>、<ref>、<bean>或<null/>元素。

​         可以将Map的键和值作为<entry>的属性定义：简单常量使用key和value来定义；bean引用通过key-ref和value-ref属性定义。

> map里面保存的是entry

```xml
public class PersonMap {
	private String name ; 
	private Map<String,Car> cars;
        ....
--------------------------------------------------
	 <!-- Map集合 -->
	 <bean id="personMap" class="com.atguigu.spring.di.PersonMap">
	 	<property name="name" value="Jerry"></property>
	 	<property name="cars" >
	 		<!-- 构造map -->
	 		<map>
				<entry key="AA"  value-ref="car"></entry>
				<entry key="BB"  value-ref="car1"></entry>
				<entry key="CC"  value-ref="car2"></entry>
	 		</map>
	 	</property>
	 </bean>
```

### 2.4.3 集合类型的bean

​         如果只能将【集合对象】配置在某个bean内部，则这个集合的配置将【不能重用】。我们需要   将集合bean的配置【拿到外面，供其他bean引用】。

​         配置集合类型的bean需要【引入util名称空间】

> Namespace里勾选util，在项目了文件里就出现了xmlns:util="..../util"

```xml
	 <bean id="personList" class="com.atguigu.spring.di.PersonList">
	 	<property name="name" value="Tom"></property>
	 	<property name="cars" ref="listBean">
	 		<!-- 构造集合 -->
	 		<!-- <list>
	 			<bean> <ref/>
	 			<ref bean="car"/>
	 			<ref bean="car1"/>
	 			<ref bean="car2"/>
	 		</list> -->
	 		
	 		<!-- <array></array> -->
	 		<!-- <set></set> -->
	 	</property>
	 </bean>
-----------------------------------------
<!-- 集合Bean -->
	 <util:list id="listBean">
	 	<ref bean="car"/>
	 	<ref bean="car1"/>
	 	<ref bean="car2"/>
	 	<!-- <bean>
	 	</bean> -->
	 </util:list>
-----------------------------------------


<util:list id="bookList">
	<ref bean="book01"/>
	<ref bean="book02"/>
	<ref bean="book03"/>
	<ref bean="book04"/>
	<ref bean="book05"/>
</util:list>

<util:list id="categoryList">
	<value>编程</value>
	<value>极客</value>
	<value>相声</value>
	<value>评书</value>
</util:list>

```

## 2.5  FactoryBean

### 2.5.1 FactoryBean

​         Spring中有两种类型的bean，一种是普通bean，另一种是工厂bean，即FactoryBean。

​         工厂bean跟普通bean不同，其返回的对象不是指定类的一个实例，其返回的是该工     厂bean的`getObject()`方法所返回的对象。

​         工厂bean必须实现org.springframework.beans.factory.FactoryBean接口。

​            ![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008210430.png)



```JAVA
<bean id="product" class="com.atguigu.spring.bean.ProductFactory">
	<property name="productName" value="Mp3" />
</bean>
--------------spring-factorybean.xml-----告诉了是个工厂bean，因为继承------------
<!--如果不知道是个继承工厂bean，还以为返回的是一个对象。当继承了之后，就会自动发现返回的是getObject方法里的内容-->
<bean id="car" class="com.atguigu.spring.factorybean.CarFactoryBean">
</bean>
-----------------CarFactoryBean.java-----------------------------
package com.atguigu.spring.factorybean;

import org.springframework.beans.factory.FactoryBean;
import com.atguigu.spring.di.Car;//引入了Car

public class CarFactoryBean implements FactoryBean<Car> {

	@Override
	public Car getObject() throws Exception {//工厂bean具体创建的bean对象是由getObject方法来返回的. 
		return  new Car("五菱宏光", "五菱", 50000);
	}

	@Override
	public Class<?> getObjectType() {//返回具体的bean对象的类型
		return Car.class;
	}
	
	@Override
	public boolean isSingleton() {//bean 可以是单例的   也可以是原型的(非单例)： 后面讲bean的作用域再研究.，默认单例的
		return true;
	}
}
------------------Main.java---------------------------
package com.atguigu.spring.factorybean;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.atguigu.spring.di.Car;

public class Main {

	public static void main(String[] args) {
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-factorybean.xml");
		Car car = ctx.getBean("car",Car.class);//第二个参数与常规不同
		System.out.println(car);//Car [=,=,=,=]
	}
}	

```

​          这样Spring使我们参与到bean对象的创建过程中

问题:  BeanFactory  与  FactoryBean的区别?

​            重写 与  重载  的区别

 

​            Collection  与 Collections 的区别 



​            Final   finally   的区别

 

## 2.6 bean的高级配置

### 2.6.1 配置信息的继承

#### 1. 背景

两个bean大部分内容都一样，这时候就使用继承。

```XML
<!--  abstract="true"  抽象bean-->
<bean id="address1"  abstract="true">
    
<!--  parent="address1"   继承bean--> 
    继承可以从父bean中继承一些配置， 但是 id  abstract  autowire 是不能被继承下来的. 
<bean id="address2" class="com.atguigu.spring.relation.Address"  parent="address1">
    
<!--  depends-on="address4"  依赖关系 -->
    依赖指的是需要定义了那个依赖后，此bean才能实例化
<bean id="address3" class="com.atguigu.spring.relation.Address" 
			parent="address1"  depends-on="address4">
```



```java
--------------spring-relation.xml---------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- bean的继承关系
		 abstract="true": 抽象bean. 不能被创建对象. class可以省略不配置
		
		 继承可以从父bean中继承一些配置， 但是 id  abstract  autowire 是不能被继承下来的. 
	 -->
	<!--abstract="true"抽象bean-->
	<bean id="address1"  abstract="true">
		<property name="city" value="BeiJing"></property>
		<property name="street" value="ChangAnJie"></property>
	</bean>
	
	<bean id="address2" class="com.atguigu.spring.relation.Address"  parent="address1">
		<!-- <property name="city" value="BeiJing"></property> -->
		<property name="street" value="WuDaoKou"></property>
	</bean>
	
	<!-- 依赖关系 -->
	<bean id="address3" class="com.atguigu.spring.relation.Address" 
			parent="address1"  depends-on="address4">
	</bean>
	
	<bean id="address4" class="com.atguigu.spring.relation.Address"></bean>
	
</beans>
-------------Address.java-----------------------
package com.atguigu.spring.relation;

public class Address {
	
	private String city ; 
	
	private String street;

	public String getCity() {
		return city;
	}

	public void setCity(String city) {
		this.city = city;
	}

	public String getStreet() {
		return street;
	}

	public void setStreet(String street) {
		this.street = street;
	}

	@Override
	public String toString() {
		return "Address [city=" + city + ", street=" + street + "]";
	}  
}
-----------------TestRelation.java-----------------
package com.atguigu.spring.relation;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestRelation {

	@Test
	public void testExtends() {
		ApplicationContext ctx  = 
				new ClassPathXmlApplicationContext("spring-relation.xml");
		
//		Address address1 = ctx.getBean("address1",Address.class);
//		System.out.println("address1:" +address1);
		
		Address address2 = ctx.getBean("address2",Address.class);
		System.out.println("address2:" + address2) ;
	}
	
	@Test
	public void testDepends() {
		ApplicationContext ctx  = 
				new ClassPathXmlApplicationContext("spring-relation.xml");
		
		
		Address address3 = ctx.getBean("address3",Address.class);
		System.out.println("address3:" + address3) ;
	}
}
```

#### 2. 配置信息的继承

```xml
<!-- 以emp01作为父bean，继承后可以省略公共属性值的配置 -->
<bean id="emp02" parent="emp01">
	<property name="empId" value="1002"/>
	<property name="empName" value="Jerry"/>
	<property name="age" value="25"/>
</bean>

```

​         Spring允许继承bean的配置，被继承的bean称为父bean。继承这个父bean的bean       称为子bean

​         子bean从父bean中继承配置，包括bean的属性配置

​         子bean也可以覆盖从父bean继承过来的配置

 

#### 3. 补充说明

​         父bean可以作为配置模板，也可以作为bean实例。若只想把父bean作为模板，可以设置<bean>的abstract 属性为true，这样Spring将不会实例化这个bean

​         如果一个bean的class属性没有指定，则必须是抽象bean

​         并不是<bean>元素里的所有属性都会被继承。比如：autowire，abstract等。

也可以忽略父bean的class属性，让子bean指定自己的类，而共享相同的属性配置。    但     此时abstract必须设为true。

 

### 2.6.2 bean之间的依赖

​         有的时候创建一个bean的时候需要保证另外一个bean也被创建，这时我们称前面的bean对后面的bean有依赖。例如：要求创建Employee对象的时候必须创建Department。       这里需要注意的是依赖关系不等于引用关系，Employee即使依赖Department也可以不引用它。

```xml
<bean id="emp03" class="com.atguigu.parent.bean.Employee" depends-on="dept ">
	<property name="empId" value="1003"/>
	<property name="empName" value="Kate"/>
	<property name="age" value="21"/>
</bean>
```



 

## 2.7  bean的作用域★

​         在Spring中，可以在<bean>元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的。

【bean默认是单例的】

bean的作用域:

|           | 简要说明    .............. |                                                              |
| --------- | -------------------------- | ------------------------------------------------------------ |
| singleton | 单例的(默认值)             | 在整个IOC容器中只能存在一个bean的对象. 而且【在IOC容器对象被创建时，就创建单例的bean的对象】. 后续每次通过getBean()方法获取bean对象时，返回的都是同一个对象. 。构造过程只会进行一次 |
| prototype | 原型的/多例的              | 在整个IOC容器中可有多个bean的对象。 在IOC容器对象被创建时， 不会创建原型的bean的对象。 而是等到【每次通过getBean()方法获取bean对象时，才会创建一个新的bean对象返回.】 |
| request   |                            | 一次请求对应一个bean对象                                     |
| session   |                            | 一次会话对应一个bean对象                                     |

​         默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例：所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，它是所有bean的默认作用域。

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008210543.png)

​         当bean的作用域为单例时，Spring会在IOC容器对象创建时就创建bean的对象实例。而当bean的作用域为prototype时，IOC容器在获取bean的实例时创建bean的实例对象。

```JAVA
----------spring.scope.xml-----------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="car" class="com.atguigu.spring.scope.Car" scope="prototype">
		<property name="brand" value="奥迪"></property>
		<property name="price" value="400000"></property>
	</bean>
</beans>

-------------------Car.java----------------------
package com.atguigu.spring.scope;

public class Car {
	private String brand; 
	private Double price ;
	
	public Car() {
		System.out.println("invoke Car Constructor ...");
	}

	public String getBrand() {
		return brand;
	}

	public void setBrand(String brand) {
		this.brand = brand;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return "Car [brand=" + brand + ", price=" + price + "]";
	} 
}
----------TestScope.java----------------------
package com.atguigu.spring.scope;

import static org.junit.Assert.*;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestScope {
	@Test
	public void testScope() {
		//创建了IOC容器对象
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-scope.xml");
		
		Car car1 = ctx.getBean("car",Car.class);
		Car car2 = ctx.getBean("car",Car.class);
		System.out.println(car1 == car2);  // 比较的是地址 
	}

}

```



## 2.8  bean的生命周期

1)        Spring IOC容器可以管理bean的生命周期，Spring允许在bean生命周期内特定的时间点执行指定的任务。

2)        Spring IOC容器对bean的生命周期进行管理的过程：

声明周期：

​         ① 通过构造器或工厂方法创建bean实例

​         ② 为bean的属性设置值和对其他bean的引用

​         ③ 调用bean的初始化方法（自定义）

​         ④ bean可以使用了

​         ⑤ 当IoC容器关闭时，调用bean的销毁方法  ctx.close();

3)        在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法

4)        bean的后置处理器

​         ① bean后置处理器允许在调用**初始化方法前后**对bean进行额外的处理

​         ② bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性。

​         ③ bean后置处理器时需要实现接口：

org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：

●postProcessBeforeInitialization(Object, String)

●postProcessAfterInitialization(Object, String)

5)        添加bean后置处理器后bean的生命周期

​         ①通过构造器或工厂方法**创建****bean****实例**

​         ②为bean的**属性设置值**和对其他bean的引用

​         ③将bean实例传递给bean后置处理器的postProcessBeforeInitialization()方法

​         ④调用bean的**初始化**方法

​         ⑤将bean实例传递给bean后置处理器的postProcessAfterInitialization()方法

​         ⑥bean可以使用了

​         ⑦当容器关闭时调用bean的**销毁方法**

```JAVA
--------spring-lifecycle.xml------------------
    <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="car" class="com.atguigu.spring.lifecycle.Car" 
			init-method="init"  destroy-method="destroy">
		<property name="brand" value="宝马"></property>
		<property name="price" value="450000"></property>
	</bean>
	
	<!-- 配置后置处理器 : Spring能自动识别是一个后置处理器 -->
	<bean class="com.atguigu.spring.lifecycle.MyBeanPostProcessor"></bean>

</beans>
---------------Car.java---------------
package com.atguigu.spring.lifecycle;

public class Car {
	
	private String brand ; 
	private Double price ;
	
	public Car() {
		System.out.println("===>1. 调用构造器创建bean对象 ");
	}
	/**
	 * 初始化方法
	 * 需要通过 init-method来指定初始化方法
	 */
	public void init() {
		System.out.println("===>3. 调用初始化方法");
	}
	
	/**
	 * 销毁方法： IOC容器关闭， bean对象被销毁.
	 */
	public void destroy() {
		System.out.println("===>5. 调用销毁方法");
	}
	
	
	public String getBrand() {
		return brand;
	}

	public void setBrand(String brand) {
		System.out.println("===>2. 调用set方法给对象的属性赋值");
		this.brand = brand;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return "Car [brand=" + brand + ", price=" + price + "]";
	} 
	
}
----------------MyBranPostProcessor.java----------------
package com.atguigu.spring.lifecycle;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

/**
 * bean的后置处理器 : 对IOC容器中所有的bean都起作用. 
 */
public class MyBeanPostProcessor implements BeanPostProcessor {
	
	/**
	 * 在bean的生命周期的初始化方法之前执行
	 * Object bean: 正在被创建的bean对象. 
	 * String beanName: bena对象的id值. 
	 */
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessBeforeInitialization");
		return bean;
	}
	/**
	 * 在bean的生命周期的初始化方法之后执行
	 */
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessAfterInitialization");
		return bean;
	}

}
----------TestLifeCycle.java-------------
package com.atguigu.spring.lifecycle;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestLifeCycle {

	@Test
	public void testLifeCycle() {
		ConfigurableApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-lifecycle.xml");
		Car car = ctx.getBean("car",Car.class);
		
		System.out.println("===>4. 使用bean对象" + car);
		//关闭容器
		
		ctx.close();//close方法是ConfigurableApplicationContext下才有的方法，所以不能定义为ApplicationContext
	}
}
```

```JAVA
//Bean的后置处理器
package com.atguigu.spring.lifecycle;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

/**
 * bean的后置处理器 : 对IOC容器中所有的bean都起作用. 
 */
public class MyBeanPostProcessor implements BeanPostProcessor {
	
	/**
	 * 在bean的生命周期的初始化方法之前执行
	 * Object bean: 正在被创建的bean对象. 
	 * String beanName: bena对象的id值. 
	 */
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessBeforeInitialization");
		return bean;
	}
	/**
	 * 在bean的生命周期的初始化方法之后执行
	 */
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessAfterInitialization");
		return bean;
	}

}
```





## 2.9 引用外部属性文件

​         当bean的配置信息逐渐增多时，查找和修改一些bean的配置信息就变得愈加困难。这时可以将一部分信息提取到bean配置文件的外部，以properties格式的属性文件保存起来，同时在bean的配置文件中引用properties属性文件中的内容，从而实现一部分属性值在发生变化时仅修改properties属性文件即可。这种技术多用于连接数据库的基本信息的配置。

> 导入两个包，c3p0-0.9.1.jar   +   mysql-connector-java-5.1.7-bin
>
> 

### 2.9.1 直接配置

```xml
<!-- 直接配置 -->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
	<property name="user" value="root"/>
	<property name="password" value="root"/>
	<property name="jdbcUrl" value="jdbc:mysql:///test"/>
	<property name="driverClass" value="com.mysql.jdbc.Driver"/>
</bean>
```

### 2.9.2 使用外部的属性文件

#### 1. 创建properties属性文件

db.properties

```xml
prop.userName=root
prop.password=root
prop.url=jdbc:mysql:///test
prop.driverClass=com.mysql.jdbc.Driver
```

#### 2. 引入context名称空间

![](https://raw.githubusercontent.com/FermHan/tuchuang/master/20191008210631.png)

#### 3.指定properties属性文件的位置

```xml

<!-- 指定properties属性文件的位置 -->
<!-- classpath:xxx 表示属性文件位于类路径下 -->
<context:property-placeholder location="classpath:jdbc.properties"/>
```

#### 4.从properties属性文件中引入属性值

```xml
<!-- 从properties属性文件中引入属性值 -->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
	<property name="user" value="${prop.userName}"/>
	<property name="password" value="${prop.password}"/>
	<property name="jdbcUrl" value="${prop.url}"/>
	<property name="driverClass" value="${prop.driverClass}"/>
</bean>
```



```xml
-----------spring-datasource.xml-----------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	
	<!-- 直接配置c3p0连接池    ComboPooledDataSource
	<bean id ="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="driverClass" value="com.mysql.jdbc.Driver"></property>
		<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/mysql"></property>
		<property name="user" value="root"></property>
		<property name="password" value="1234"></property>
		<property name="initialPoolSize" value="5"></property>   
		<property name="maxPoolSize" value="10"></property>
	</bean>
	
	 -->
	 
	 <!-- 通过引入外部的属性文件配置c3p0连接池 -->
	 <!-- 引入外部的属性文件 -->
	 <!-- 1 
		 <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		 	<property name="location" value="classpath:db.properties"></property>
		 </bean>
	 -->
	 <!-- 2  -->
	 <context:property-placeholder location="classpath:db.properties"/>
	 
	 <!-- 配置c3p0连接池 -->
	 <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
	 	<property name="driverClass" value="${jdbc.driver}"></property>
	 	<property name="jdbcUrl" value="${jdbc.url}"></property>
	 	<property name="user" value="${jdbc.username}"></property>
	 	<property name="password" value="${jdbc.password}"></property>
	 
	 </bean>

</beans>
-------------db.properties--------------
# k = v 
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mysql
jdbc.username=root
jdbc.password=1234
------------TestDataSource.java------------
package com.atguigu.spring.dataSource;

import javax.sql.DataSource;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestDataSource {

	@Test
	public void test() throws Exception {
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-datasource.xml");
		
		DataSource ds = ctx.getBean("dataSource",DataSource.class);
		
		System.out.println("ds:" + ds);
		
		System.out.println(ds.getConnection());
	}

}
```





## 2.10 自动装配

### 2.10.1 自动装配的概念

1)        手动装配：以value或ref的方式**明确指定属性值**都是手动装配。

2)        自动装配：根据指定的装配规则，**不需要明确指定**，Spring**自动**将匹配的属性值**注入**bean中。（只能自动装配对象类型的数型，即除了字面值之外的，如Car，Person类型的）

### 2.10.2 装配模式

##### 1)        根据**类型**自动装配：

定义：将类型匹配的bean作为属性注入到另一个bean中。若IOC容器中有多个与目标bean类型一致的bean，Spring将无法判定哪个bean最合适该属性，所以不能执行自动装配

在bean标签中添加  <bean autowire="byType">

- byType: 使用bean的属性的类型与IOC容器中<bean>的class进行匹配。 如果唯一匹配则装配成功。如果匹配到多个兼容类型的bean。则跑出异常。

原理是：

比如我们有3个类，Person，Car，Address。其中后两个在Person类中定义为set，get方法（可以理解为后两个是Person的成员变量）。

当把Person在bean中指定为自动装配时，会寻找后两个Car，Address对应的set，get方法，然后去掉set，get单词后小写car，address。根据这个名字寻找对应的全类名bean（class=全类名的bean），而找到的bean中可以给car和address赋值。

所以此时我们在xml中不能定义全类名相同和id不同的bean，此时byType自动装配会报错。



##### 2)        根据**名称**自动装配：

必须将目标bean的名称和属性名设置的完全相同

在bean标签中添加  <bean autowire="byName">

- byName: 使用bean的属性名与IOC容器中<bean>的id值进行匹配. 匹配成功则装配成功. 

原理是：

与byType自动装配类似，不同的是我们拿car，address去寻找id等于这两个的bean，然后装配上去。这就要求我们必须定义bean为car和address，而不能定义为car1等与类名不同的id。

##### 3)        通过构造器自动装配：

定义：当bean中存在多个构造器时，此种自动装配方式将会很复杂。不推荐使用。



```java
---------------spring-autowire.xml--------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	
	<!-- Car  byNmae时，id必须写成car才能装配上去。byType时id可以不一致-->
	<bean id="car1" class="com.atguigu.spring.autowire.Car">
		<property name="brand" value="奔驰"></property>
		<property name="price" value="500000"></property>
	</bean>
	
	<bean id="car2" class="com.atguigu.spring.autowire.Car">
		<property name="brand" value="宝马"></property>
		<property name="price" value="500000"></property>
	</bean>
	
	<!-- Address -->
	<bean id="address" class="com.atguigu.spring.autowire.Address">
		<property name="province" value="山西省"></property>
		<property name="city" value="太原市"></property>
	</bean>
	
	<!-- Person  : 演示自动装配 -->
	<bean id="person" class="com.atguigu.spring.autowire.Person" autowire="byType">
		<property name="name" value="Tom"></property>
        <!-- 以前我们都用:<property name="name" ref="car1"></perperty>  -->
	</bean>
</beans>
----------------Person.java--------------------------
package com.atguigu.spring.autowire;

public class Person {
	private String name ; 
	private Car car ; 
	private Address address ;

	+get set toStrng....
	} 
}
-----------------Address.java------------------------
package com.atguigu.spring.autowire;

public class Address {
	private String province ;  //省份
	private String city ; //城市
    
    +get set toStrng....
	} 
}
----------TestAutoWire.java---------------------------
package com.atguigu.spring.autowire;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestAutoWire {

	@Test
	public void testAutoWire() {
		
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-autowire.xml");
		
		Person person = ctx.getBean("person",Person.class);
		System.out.println(person);
	}
}
```

### 2.10.3 选用建议 

​         相对于使用注解的方式实现的自动装配，在XML文档中进行的自动装配略显笨拙，在项目中更多的使用注解的方式实现。

## 2.11 通过注解配置bean

### 2.11.1 概述

​         相对于XML方式而言，通过注解的方式配置bean更加简洁和优雅，而且和MVC组件化开发的理念十分契合，是开发中常用的使用方式。

 ```xml
@Component

MVC：Model View Controller
视图层/表现层/表述层    MVC  VCM   @Controller
业务逻辑层    Service             @Service
数据访问层/持久层   DAO            @Repository

C调S  S调DAO

接口解耦
在xml中配置组件扫描的目的：我们在类上面加了注解了，我们得让spring知道加的注解。扫描加了注解的类，并管理到IOC容器中 。需要导入Context命名空间。
base-package: 基包. Spring会扫描指定包以及子包下所有的类，将带有注解的类管理到IOC容器中。因此，xml文件要放在与包同目录下
<context:component-scan base-package="com.atguigu.spring.annotation" use-default-filters="true">
    

 * 
使用注解需要导入包APOP

 ```

### 2.11.2 使用注解标识组件

| 组件                          | 说明                                           | 例子 |
| ----------------------------- | ---------------------------------------------- | ---- |
| 普通组件：@Component          | 标识一个受Spring IOC容器管理的组件             |      |
| 持久化层组件：@Repository     | 标识一个受Spring IOC容器管理的持久化层组件     |      |
| 业务逻辑层组件：@Service      | 标识一个受Spring IOC容器管理的业务逻辑层组件   |      |
| 表述层控制器组件：@Controller | 标识一个受Spring IOC容器管理的表述层控制器组件 |      |
不清楚才用Component

如：

```
@Cotroller 注解的作用: 
相当于在xml文件中写入如下配置: 
<bean id="userController" class="com.atguigu.spring.annotation.controller.UserController">

注解默认的id值 就是类名首字母小写， 可以在注解中手动指定id值:@Controller(value="id值"),可以简写为:@Controller("id值")

<!-- 指定扫描  必须 设置use-default-filters="false"
		
		   排除扫描   use-default-filters="true"默认值，可以不用设置   -->
```



```JAVA
----------------------spring-annotation.xml---------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	
	<!-- 组件扫描:  扫描加了注解的类，并管理到IOC容器中 
		base-package: 基包. Spring会扫描指定包以及子包下所有的类，将带有注解的类管理到IOC容器中
	-->
	<context:component-scan base-package="com.atguigu.spring.annotation" use-default-filters="true">
		<!-- 指定扫描  必须 设置use-default-filters="false"
		
		   排除扫描   use-default-filters="true"   -->
		<!-- <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
		<!-- <context:include-filter type="assignable" expression="com.atguigu.spring.annotation.controller.UserController"/> -->
		
		<!-- <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
		<!-- <context:exclude-filter type="assignable" expression="com.atguigu.spring.annotation.controller.UserController"/> -->
	
	</context:component-scan>

</beans>
----------------------UserController.java--------------------------
package com.atguigu.spring.annotation.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import com.atguigu.spring.annotation.service.UserService;
import com.atguigu.spring.annotation.service.UserServiceImpl;

/**
 * @Cotroller 注解的作用: 
 * 相当于在xml文件中添加了: 
 * <bean id="userController" class="com.atguigu.spring.annotation.controller.UserController">
 * 
 * 注解默认的id值 就是类名首字母小写， 可以在注解中手动指定id值:@Controller(value="id值"),可以简写为:@Controller("id值")
 */
@Controller
public class UserController {
	
	@Autowired //根据的是byName还是byType呢？
	private UserService userService;//注意使用接口类型，不要使用Imple类型。不然就耦合起来了
    // 怎么才能把userService装配进来呢？IOC擅长资源注入。想要US，就把US推送过来了。需要加个@Autowired
	
	public void  regist() {
		
		userService.handleAddUser();
	}
}

----------------------TestAnnotation.java------------------------
package com.atguigu.spring.annotation.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.spring.annotation.controller.UserController;
import com.atguigu.spring.annotation.dao.UserDao;
import com.atguigu.spring.annotation.service.UserService;

public class TestAnnotation {
	
	@Test
	public void testAnnotation() {
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-annotation.xml");
		UserController  uc =  ctx.getBean("userController",UserController.class);
		System.out.println("userController:" + uc );
		
//		UserService us = ctx.getBean("userServiceImpl",UserService.class);
//		System.out.println("userService:" + us);
//		
//		UserDao  ud = ctx.getBean("userDaoJdbcImpl",UserDao.class);
//		System.out.println("userDao: " + ud );
		
		uc.regist();
	}
}

```



5)        组件命名规则

​         ①默认情况：使用组件的简单类名首字母小写后得到的字符串作为bean的id

​         ②使用组件注解的value属性指定bean的id

​         注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以                       @Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。

 

### 2.11.3  扫描组件

定义了基包后，默认情况下回扫描这个下面所有的类。将带有注解的类管理到IOC容器中。

```XML
指定扫描  必须 设置use-default-filters="false"
		
		   排除扫描   use-default-filters="true"

<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
annotation时选择的是注解

<context:include-filter type="assignable" expression="com.atguigu.spring.annotation.controller.UserController"/>
UserController时，选择的是全类名
```



​         组件被上述注解标识后还需要通过Spring进行扫描才能够侦测到。

1)        指定被扫描的package

```xml
<context:component-scan base-package="com.atguigu.component"/>
```

2)        详细说明

​         ①**base-package**属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包及其子包中的所有类。

​         ②当需要扫描多个包时可以使用逗号分隔。

​         ③如果仅希望扫描特定的类而非基包下的所有类，可使用resource-pattern属性过滤特定的类，示例：

```xml
<context:component-scan 
	base-package="com.atguigu.component" 
	resource-pattern="autowire/*.class"/>
```

​         ④包含与排除

​              ●<context:include-filter>子节点表示要包含的目标类

注意：通常需要与use-default-filters属性配合使用才能够达到“仅包含某些组件”这样的效果。即：通过将use-default-filters属性设置为false， 禁用默认过滤器，然后扫描的就只是include-filter中的规则指定的组件了。

​              ●<context:exclude-filter>子节点表示要排除在外的目标类

​              ●component-scan下可以拥有若干个include-filter和exclude-filter子节点

​              ●过滤表达式

| 类别       | 示例                      | 说明                                                         |
| ---------- | ------------------------- | ------------------------------------------------------------ |
| annotation | com.atguigu.XxxAnnotation | 过滤所有标注了XxxAnnotation的类。这个规则根据目标组件是否标注了指定类型的注解进行过滤。 |
| assignable | com.atguigu.BaseXxx       | 过滤所有BaseXxx类的子类。这个规则根据目标组件是否是指定类型的子类的方式进行过滤。 |
| aspectj    | com.atguigu.*Service+     | 所有类名是以Service结束的，或这样的类的子类。这个规则根据AspectJ表达式进行过滤。 |
| regex      | com\.atguigu\.anno\.*     | 所有com.atguigu.anno包下的类。这个规则根据正则表达式匹配到的类名进行过滤。 |
| custom     | com.atguigu.XxxTypeFilter | 使用XxxTypeFilter类通过编码的方式自定义过滤规则。该类必须实现org.springframework.core.type.filter.TypeFilter接口 |

3)        JAR包

必须在原有JAR包组合的基础上再导入一个：spring-aop-4.0.0.RELEASE.jar

### 2.11.4 组件装配

1)        需求

​         Controller组件中往往需要用到Service组件的实例，Service组件中往往需要用到       Repository组件的实例。Spring可以通过注解的方式帮我们实现属性的装配。

2)        实现依据

​         在指定要扫描的包时，<context:component-scan> 元素会自动注册一个bean的后置处     理器：AutowiredAnnotationBeanPostProcessor的实例。该后置处理器可以 自动装配标记   了**@Autowired**、@Resource或@Inject注解的属性。

3)        @Autowired注解

使用@Autowired自动装配，根据的是Name还是Type呢？

@Autowired工作机制: 

-  首先会使用`byType`的方式进行自动装配，如果能唯一匹配，则装配成功，
-  如果匹配到多个兼容类型的bean, 还会尝试使用`byName`的方式进行唯一确定. 
- 如果能唯一确定，则装配成功，如果不能唯一确定，则装配失败，抛出异常. 
- 默认情况下， 使用@Autowired标注的属性必须被装配，如果装配不了，也会抛出异常. 
- 可以使用required=false来设置不是必须要被装配. 
- 如果匹配到多个兼容类型的bean，可以使用@Qualifier来进一步指定要装配的bean的id值 。

- AutoWired和Qualifier可以用在成员变量上，也可以用在set方法上。用在成员变量上就无需也处理set和get方法了，这是以前 的方法。现在都有在成员上。

​         ①根据类型实现自动装配。

​         ②构造器、普通字段(即使是非public)、一切具有参数的方法都可以应用@Autowired 注解

​         ③默认情况下，所有使用@Autowired注解的属性都需要被设置。当Spring找不到匹 配的bean装配属性时，会抛出异常。

​         ④若某一属性允许不被设置，可以设置@Autowired注解的required属性为 false

​         ⑤默认情况下，当IOC容器里存在多个类型兼容的bean时，Spring会尝试匹配bean  的id值是否与变量名相同，如果相同则进行装配。如果bean的id值不相同，通过类 型的自动装配将无法工作。此时可以在@Qualifier注解里提供bean的名称。Spring    甚至允许在方法的形参上标注@Qualifiter注解以指定注入bean的名称。        

​		⑥@Autowired注解也可以应用在数组类型的属性上，此时Spring将会把所有匹配的bean进行自动装配。

​         ⑦@Autowired注解也可以应用在集合属性上，此时Spring读取该集合的类型信息，然后自动装配所有与之兼容的bean。

​         ⑧@Autowired注解用在java.util.Map上时，若该Map的键值为String，那么 Spring将自动装配与值类型兼容的bean作为值，并以bean的id值作为键。

​                   

4)        @Resource

​         @Resource注解要求提供一个bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为bean的名称。

5)        @Inject

​         @Inject和@Autowired注解一样也是按类型注入匹配的bean，但没有reqired属性。

```JAVA
-----------------spring-annotation.xml----------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	
	<!-- 组件扫描:  扫描加了注解的类，并管理到IOC容器中 
		base-package: 基包. Spring会扫描指定包以及子包下所有的类，将带有注解的类管理到IOC容器中
	-->
	<context:component-scan base-package="com.atguigu.spring.annotation" use-default-filters="true">
		<!-- 指定扫描  必须 设置use-default-filters="false"
		
		   排除扫描   use-default-filters="true"   -->
		<!-- <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
		<!-- <context:include-filter type="assignable" expression="com.atguigu.spring.annotation.controller.UserController"/> -->
		
		<!-- <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
		<!-- <context:exclude-filter type="assignable" expression="com.atguigu.spring.annotation.controller.UserController"/> -->
	
	</context:component-scan>

</beans>

-----------------UserController.java---------------------
package com.atguigu.spring.annotation.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.atguigu.spring.annotation.service.UserService;
import com.atguigu.spring.annotation.service.UserServiceImpl;

/**
 * @Cotroller 注解的作用: （其实那4个注解使用哪个都可以，跟具体名无关系，只是容易阅读）
 * 相当于在xml文件中: 
 * <bean id="userController" class="com.atguigu.spring.annotation.controller.UserController">
 * 
 * 注解默认的id值 就是类名首字母小写， 可以在注解中手动指定id值:@Controller(value="id值"),可以简写为:@Controller("id值")
 * 
 */
@Controller
public class UserController {
	
	@Autowired
	private UserService userService;
	
	public void  regist() {
		
		userService.handleAddUser();
	}
}
-----------------UserServiceImpl.java-----------
package com.atguigu.spring.annotation.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.atguigu.spring.annotation.dao.UserDao;

@Service
public class UserServiceImpl implements UserService {

 /*
	 *  如果匹配到多个兼容类型的bean，可以使用@Qualifier来进一步指定要装配的bean的id值 。
	 *  
	 *  @Autowired @Qualifier 注解即可在成员变量上，也可以加在对应的set方法上.. 
	 */
    //设置为required=false后表示能装配上就装配上，装配不上就不用装配了不报错了
	@Autowired(required=false)   // 自动装配  byName  byType ?????
	@Qualifier("userDaoJdbcImpl")
	private UserDao userDao ; 
	
//	@Autowired(required=false)   // 自动装配  byName  byType ?????
//	@Qualifier("userDaoJdbcImpl")
//	public void setUserDao(UserDao userDao) {
//		this.userDao = userDao;
//	}
	
	@Override
	public void handleAddUser() {
		//处理业务
		
		userDao.addUser();
	}
}
----------------UserDaoJdbcImpl.java---------------
package com.atguigu.spring.annotation.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoJdbcImpl  implements UserDao{

	@Override
	public void addUser() {
		System.out.println("UserDao  Jdbc .....");
	}
}
----------------UserDaoMybatisImpl.java----------------
package com.atguigu.spring.annotation.dao;

import org.springframework.stereotype.Repository;

// @Repository("userDao")这样就可以唯一确定了，指定了放入xml的id值。到时候自动装配的时候就可以byName获取到UserDaoMybatisImpl
@Repository
public class UserDaoMybatisImpl implements UserDao {
	
	@Override
	public void addUser() {
		System.out.println("UserDao  Mybatis .....");
	}
}
-------------TestAnnotation.java------------------------
package com.atguigu.spring.annotation.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.spring.annotation.controller.UserController;
import com.atguigu.spring.annotation.dao.UserDao;
import com.atguigu.spring.annotation.service.UserService;

public class TestAnnotation {
	
	@Test
	public void testAnnotation() {
		ApplicationContext ctx = 
				new ClassPathXmlApplicationContext("spring-annotation.xml");
		UserController  uc =  ctx.getBean("userController",UserController.class);
		System.out.println("userController:" + uc );
		
//		UserService us = ctx.getBean("userServiceImpl",UserService.class);
//		System.out.println("userService:" + us);
//		
//		UserDao  ud = ctx.getBean("userDaoJdbcImpl",UserDao.class);
//		System.out.println("userDao: " + ud );
		
		uc.regist();	
	}
}

```

